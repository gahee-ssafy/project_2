{
    "filename": "ai_server/main.py",
    "analysis": "제공해주신 `ai_server/main.py` 소스 코드는 **FastAPI**를 기반으로 하여, 사용자가 업로드한 코드 파일을 **Google Gemini AI**를 통해 분석하고, 그 결과를 **로컬 파일 시스템(JSON)** 및 **Django 백엔드 서버**로 전송하는 기능을 수행합니다.\n\n주요 구성 요소와 흐름에 대한 상세 분석은 다음과 같습니다.\n\n---\n\n### 1. 주요 구성 및 설정\n*   **프레임워크**: `FastAPI`를 사용하여 비동기 API 서버를 구축했습니다.\n*   **AI 모델**: `google-genai` 라이브러리를 통해 Gemini API를 호출합니다. 코드상에 모델명이 `gemini-3-flash-preview`로 되어 있는데, 이는 최신/실험적 모델을 사용하려는 의도로 보입니다. (현재 공식 모델명 확인 필요: 예: `gemini-1.5-flash`)\n*   **데이터 통신**: `httpx` 라이브러리를 사용하여 Django 서버(`http://127.0.0.1:8000`)와 비동기 HTTP 통신을 수행합니다.\n*   **데이터 저장**: \n    1.  `analysis_results/` 폴더에 각 분석 결과를 `.json` 파일로 저장합니다.\n    2.  Django 서버의 API(`DJANGO_URL`)로 분석 결과를 POST 요청 보냅니다.\n\n### 2. 주요 기능 및 코드 흐름 분석\n\n#### ① 파일 분석 API (`POST /ai/analyze-file`)\n가장 핵심적인 엔드포인트입니다.\n1.  **파일 수신 및 읽기**: `UploadFile`을 통해 파일을 받고, `utf-8`로 디코딩하여 텍스트를 추출합니다.\n2.  **Gemini AI 연동**: 추출된 코드 텍스트를 프롬프트와 함께 Gemini 모델에 전달하여 분석 결과(텍스트)를 생성합니다.\n3.  **데이터 구조화**: \n    *   파일명, 분석 내용, 원본 코드, 현재 시간(`timestamp`)을 하나의 딕셔너리로 구성합니다.\n4.  **Django 전송**: `send_to_django` 함수를 호출하여 외부 백엔드 서버에 데이터를 동기화합니다.\n5.  **로컬 저장**: 파일 시스템의 안정성을 위해 공백을 언더바(`_`)로 치환한 파일명으로 JSON 파일을 생성합니다.\n\n#### ② 결과 목록 조회 API (`GET /ai/results`)\n*   `SAVE_DIR` 폴더 내에 저장된 모든 `.json` 파일 목록을 읽어와 파일 이름만 리스트 형태로 반환합니다.\n\n#### ③ 외부 통신 함수 (`send_to_django`)\n*   `httpx.AsyncClient`를 사용하여 비동기적으로 Django 서버에 데이터를 보냅니다.\n*   예외 처리(`try-except`)가 되어 있어 Django 서버가 꺼져 있더라도 전체 프로세스가 중단되지 않고 로그만 남기도록 설계되었습니다.\n\n---\n\n### 3. 코드의 장점 및 특징\n1.  **상세한 로깅**: `[DEBUG]`, `[ERROR]` 등 단계별로 `print`문을 사용하여 서버 동작 상태를 파악하기 쉽습니다.\n2.  **비동기 처리**: `await file.read()`, `await send_to_django()` 등 비동기 방식을 사용하여 I/O 대기 효율을 높였습니다.\n3.  **데이터 안전성**: 로컬 JSON 저장과 외부 DB(Django를 통한) 저장을 병행하여 데이터 손실 가능성을 낮췄습니다.\n4.  **파일 시스템 관리**: `SAVE_DIR`이 없으면 자동으로 생성하는 로직이 포함되어 있습니다.\n\n---\n\n### 4. 개선 제안 및 주의사항\n\n1.  **모델 이름 확인**:\n    현재 `gemini-3-flash-preview`라는 모델명은 실제 Google AI SDK에서 지원하는 이름인지 확인이 필요합니다. (보통 `gemini-1.5-flash` 또는 `gemini-2.0-flash-exp` 등이 사용됩니다.)\n\n2.  **인코딩 이슈**:\n    `content.decode(\"utf-8\")` 부분에서 텍스트 파일이 아닌 이미지나 바이너리 파일이 업로드될 경우 에러가 발생합니다. 파일의 `content_type`을 체크하거나 예외 처리를 강화할 필요가 있습니다.\n\n3.  **파일 저장 시의 동기 코드**:\n    `with open(...) as f: json.dump(...)` 부분은 **동기(Sync)** 코드입니다. 파일 쓰기가 일어나는 동안 FastAPI의 이벤트 루프가 잠시 차단될 수 있습니다. 파일이 매우 많거나 크다면 `aiofiles` 같은 라이브러리를 사용하여 비동기로 저장하는 것이 좋습니다.\n\n4.  **보안**:\n    현재는 누구나 `/ai/analyze-file`에 접근할 수 있습니다. 운영 환경에서는 API Key나 인증 로직이 추가되어야 합니다.\n\n5.  **ChromaDB 주석**:\n    코드 중간에 `ChromaDB` 관련 주석과 로직 흔적(Step 3)이 보입니다. 벡터 데이터베이스를 도입하여 이전 분석 결과를 검색하는 RAG(Retrieval-Augmented Generation) 기능을 구현하려 했던 것으로 추측됩니다. 추후 확장 시 이 부분을 구현하면 좋습니다.\n\n### 요약\n이 코드는 **\"코드 파일 업로드 -> AI 분석 -> 분석 결과 로컬 저장 및 외부 서버 전송\"**의 파이프라인을 깔끔하게 구현한 FastAPI 애플리케이션입니다. 테스트 및 프로토타입 용도로 매우 훌륭한 구조를 가지고 있습니다.",
    "code_content": "from dotenv import load_dotenv\nfrom fastapi import FastAPI, HTTPException, UploadFile, File\nfrom google import genai\n\n# import chromadb\nimport json\nimport os\nfrom datetime import datetime\n\n# 통신\nimport httpx\n\nload_dotenv()\napp = FastAPI()\n# [중요] API 주소 \nDJANGO_URL = \"http://127.0.0.1:8000/api/ai/results/\"\n\n# 엔진 초기화\nclient = genai.Client(api_key=os.getenv(\"GEMINI_API_KEY\"))\n\n# 저장 폴더 경로 설정 (없으면 생성)\nSAVE_DIR = \"analysis_results\"\nif not os.path.exists(SAVE_DIR):\n    os.makedirs(SAVE_DIR)\n\n\n\n@app.post(\"/ai/analyze-file\")\nasync def analyze_file(file: UploadFile = File(...)):\n    try:\n        # [Step 1] 파일 내용 읽기\n        print(f\"[DEBUG] 수신된 파일명: {file.filename}\") # 파일 도달 확인\n        content = await file.read()\n        code_text = content.decode(\"utf-8\")\n        print(f\"[DEBUG] 파일 내용 일부(50자): {code_text[:50]}...\") # 디코딩 성공 확인\n\n        # [Step 2] Gemini AI에게 파일 내용 전달 및 분석\n        print(f\"[DEBUG] Gemini API 호출 시도...\")\n        response = client.models.generate_content(\n            model=\"gemini-3-flash-preview\",\n            contents=f\"다음 파일({file.filename})의 소스 코드를 분석해줘:\\n\\n{code_text}\"\n        )\n        analysis_result = response.text\n        print(f\"[DEBUG] Gemini 분석 결과 수신 완료 (길이: {len(analysis_result)}자)\")\n\n        ####################################################\n        # [Step 3] ChromaDB에 파일 내용과 분석 결과 적재\n        print(f\"[DEBUG] ChromaDB 데이터 적재 시도...\")\n        # 현재 시각을 YYYY-MM-DD HH:MM:SS 형식으로 추출\n        current_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        print(f\"[DEBUG] 3-1: 타임스탬프 생성 완료 ({current_time})\")\n\n        # ID 값 검증 로직 추가\n        safe_id = str(file.filename).strip().replace(\" \", \"_\")\n        print(f\"[DEBUG] 3-2: 준비된 ID값 확인: '{safe_id}'\")\n\n        # 저장할 데이터 구조화\n        data_to_save = {\n            \"filename\": file.filename,\n            \"analysis\": analysis_result,\n            \"code_content\": code_text,\n            \"timestamp\": current_time\n        }\n        \n        # Django로 데이터 전송\n        await send_to_django(data_to_save) \n\n\n        # 파일명에서 공백 및 특수문자 치환 (안전한 파일명 생성)\n        safe_filename = file.filename.replace(\" \", \"_\").replace(\"/\", \"_\")\n        json_file_path = os.path.join(SAVE_DIR, f\"{safe_filename}.json\")\n\n        with open(json_file_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(data_to_save, f, ensure_ascii=False, indent=4)\n            \n        print(f\"[DEBUG] JSON 저장 성공: {json_file_path}\")\n\n        return {\n            \"status\": \"success\",\n            \"filename\": file.filename,\n            \"analysis\": analysis_result,\n            \"saved_at\": json_file_path\n        }\n\n    except Exception as e:\n        print(f\"[CRITICAL ERROR] 타입: {type(e).__name__}\")\n        print(f\"[CRITICAL ERROR] 내용: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"파일 분석 실패: {str(e)}\")\n    \n@app.get(\"/ai/results\")\nasync def list_results():\n    files = os.listdir(SAVE_DIR)\n    return {\"results\": [f.replace(\".json\", \"\") for f in files if f.endswith(\".json\")]}\n\n\nasync def send_to_django(payload: dict):\n    \"\"\"Django 백엔드로 데이터를 전송하는 서브 공정\"\"\"\n    async with httpx.AsyncClient() as client:\n        try:\n            print(f\"[DEBUG] Django로 데이터 전송 시도: {DJANGO_URL}\")\n            response = await client.post(DJANGO_URL, json=payload, timeout=10.0)\n            \n            if response.status_code == 200:\n                print(f\"[DEBUG] Django 전송 성공: {response.json()}\")\n            else:\n                print(f\"[WARNING] Django 응답 에러: {response.status_code}\")\n        except Exception as e:\n            print(f\"[ERROR] Django 서버가 꺼져있거나 통신 불가: {str(e)}\")\n",
    "timestamp": "2026-02-11 13:16:58"
}